SYNTAX:

class ==> 

{public/default} {abstract/final --if needed} class/interface {class_name} {....... }

abstract/final --> not needed for interface


variable ==> 

{public/default/protected/private} {transient - if needed} {volatile/final --if needed} {static --if needed} {datatype} {variable_name} = {value} ;

transient --> marking a variable as transient indicates that it should not be serialized.
volatile  --> to indicate that a variable's value will be modified by different threads.

method ==>

{public/default/protected/private} {abstract/final --if needed} {static --if needed} {return type --> void & others} {method_name} (parameters ...any number) { ... }


NAMING CONVENTION:

DATATYPE :

1.How bit level datatype consumes memory.
2. byte has range of 2^7-1 to -2^7 . If exceeds we have to cast explicitly and it may leads to overflow / underflow.
3. other datatypes their range based on memory they take. char has only range of 0 - 65535.
4. byte --> short --> int <-- long (but with casting) 
                      int --> float --> double 
                      long --> float --> double
5. by default whole number will be int & decimal number will be double.
6. we use f/F , d/D, l/L for proper identification.
7. If the value is out of range it will come to negative range (like rotation)
8. we can use large numbers like 2_147_483_647.

EXECUTION ORDER :

static block --> main method --> non-static block (executed at every object creation)--> non-static method / static method (based on calling order).

static block -->initialize static variables or perform one-time actions when the class is loaded

non -static block --> called everytime when a new object created.

VARIABLE TYPES:

1.Instance Variable:
     different for each object.
     initialization not mandatory.(default value applied)
     created along with its object and destroyed along with its object.
2.Static variable:
     only difference is static keyword & this is common for all object.
     if changed through one object it'll be reflected in all objects.
3.Local/ method variable:
     initialization is mandatory.
     local to method/constructor/block. cant be accessed outside unless passed/ returned from a method.
     only default AM / final permitted.

if we need to call NON-STATIC in STATIC method we need object.

IMPORTANT KEYWORDS STATIC / FINAL / SUPER / THIS:

STATIC : ( class, method , variable , block )

1. static can be used in nested class (class inside class)
2. If we use static it belongs to the class.
3. We can't use static/final keyword with constructor.
4. we can't override static/final/private  method / only can overload it.
5. static can be used in object creation in case of singleton pattern.

FINAL : (class , method , variable) 

1. final class can't be inherited.
2. final method can't be overridden
3. final variable can't be changed. variable cannot be modified after it has been initialized. (IMMUTABLE)

final var --> Used for constants that are specific to each object instance and remain unchanged after initialization.
static final var --> Used for constants that are associated with the class itself and are shared across all instances.

SUPER : (INHERITANCE)

1. can't use inside super in static content.
2. constructor call must be the first statement in constructor.

3. can be used to call variable of parent class (super.parentClassVariable .. both static & non-static) (but static should be accessed only with class name)
4. can be used to call method of parent class (super.parentClassMethod .. both static & non-static) (but static should be accessed only with class name)
    (If parent's method not implemented in child class no need to use super)
5. Can call parent's constructor with its param.(can be called only from child constructor)

THIS : (ENCAPSULATION)

1.to refer instance(non-static) variable in current class. (but static should be accessed only with class name)
2.this(....params) to call current class matching constructor.
3.this can be used to refer "current class Instance". (use -> method chaining)
4.the previous one can be passed as argument to another method which have (Class objName) as Parameter.
5.this can be used to call current class method with matching params.
6.




